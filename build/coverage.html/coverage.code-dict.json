{"/home/travis/build/npmtest/node-npmtest-ibm_db/test.js":"/* istanbul instrument in package npmtest_ibm_db */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ibm_db/lib.npmtest_ibm_db.js":"/* istanbul instrument in package npmtest_ibm_db */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ibm_db = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ibm_db = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ibm_db/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ibm_db && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ibm_db */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ibm_db\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ibm_db.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ibm_db.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ibm_db.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ibm_db.__dirname + '/lib.npmtest_ibm_db.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ibm_db/node_modules/ibm_db/lib/odbc.js":"/*\n  Copyright (c) 2013, Dan VerWeire <dverweire@gmail.com>\n  Copyright (c) 2010, Lee Smith <notwink@gmail.com>\n\n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted, provided that the above\n  copyright notice and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n// Setting SQLLIB bin path to the path env before load for windows\nvar os = require('os'),\n    path = require('path');\nif(os.platform() == 'win32')\n{\n  process.env.PATH = process.env.PATH + ';' +\n                       path.resolve(__dirname, '../installer/clidriver/bin');\n}\n\nvar odbc = require(\"bindings\")(\"odbc_bindings\")\n  , SimpleQueue = require(\"./simple-queue\")\n  , util = require(\"util\")\n  , Readable = require('stream').Readable\n  , Q = require('q');\n\n\n// Call of odbc.ODBC() loads odbc library and allocate environment handle.\n// All calls of new Database() should use this same odbc unless passed as\n// options.odbc. ENV will keep value of this odbc after first call of Database.\nvar ENV;\n\nmodule.exports = function (options)\n{\n  return new Database(options);\n};\n\nmodule.exports.Database = Database;\nmodule.exports.ODBC = odbc.ODBC;\nmodule.exports.ODBCConnection = odbc.ODBCConnection;\nmodule.exports.ODBCStatement = odbc.ODBCStatement;\nmodule.exports.ODBCResult = odbc.ODBCResult;\n\nexports.debug = false;\nvar ibmdbStartTime = new Date();\nvar getElapsedTime = function(){\n            var tstamp = (new Date() - ibmdbStartTime)/1000.0;\n            //process.stdout.write(tstamp + \" :: \");\n            return (tstamp + \" :: \");\n            };\nmodule.exports.getElapsedTime = getElapsedTime;\n\nmodule.exports.debug = function(x) {\n    if(x) {\n        exports.debug = true;\n        console.log(\"node-ibm_db logs enabled.\");\n    }\n    else {\n        exports.debug = false;\n        console.log(\"node-ibm_db logs disabled.\");\n    }\n};\n\nmodule.exports.open = function (connStr, options, cb)\n{\n  var db, deferred;\n\n  var DBFactory = function(options) {\n    return new Database(options);\n  };\n\n  if (!cb && typeof options !== 'function')\n  {\n    if(!options)\n    {\n      options = null;\n    }\n    db = DBFactory(options);\n    deferred = Q.defer();\n    db.open(connStr, function(err) {\n      if (err)\n      {\n        deferred.reject(err);\n      }\n      else\n      {\n        deferred.resolve(db);\n      }\n    });\n    return deferred.promise;\n  }\n\n  else if (typeof options === 'function')\n  {\n    cb = options;\n    options = null;\n  }\n\n  db = DBFactory(options);\n\n  db.open(connStr, function (err) {\n    cb(err, db);\n  });\n};  // ibmdb.open\n\nmodule.exports.openSync = function (connStr, options)\n{\n  var db = new Database(options);\n  db.openSync(connStr);\n  return db;\n}; // ibmdb.openSync\n\nmodule.exports.close = function(db)\n{\n  if(db && typeof(db) === \"object\")\n  {\n    for(key in db)\n    {\n      delete db[key];\n    }\n    delete db;\n    db = undefined;\n  }\n}; // ibmdb.close\n\nfunction Database(options)\n{\n  var self = this;\n\n  options = options || {};\n\n  self.odbc = (options.odbc) ? options.odbc : ((ENV) ? ENV : new odbc.ODBC());\n  if(!ENV) ENV = self.odbc;\n  self.queue = new SimpleQueue();\n  self.fetchMode = options.fetchMode || null;\n  self.connected = false;\n  self.connectTimeout = options.connectTimeout || null;\n  self.systemNaming = options.systemNaming;\n} // Database()\n\n//Expose constants\nObject.keys(odbc.ODBC).forEach(function (key) {\n  if (typeof odbc.ODBC[key] !== \"function\")\n  {\n    //On the database prototype\n    Database.prototype[key] = odbc.ODBC[key];\n\n    //On the exports\n    module.exports[key] = odbc.ODBC[key];\n  }\n});\n\nDatabase.prototype.open = function (connStr, cb) {\n  var self = this, deferred;\n\n  if (typeof(connStr) === \"object\")\n  {\n    var obj = connStr;\n    connStr = \"\";\n\n    Object.keys(obj).forEach(function (key) {\n      connStr += key + \"=\" + obj[key] + \";\";\n    });\n  }\n\n  if (!cb)\n  {\n    deferred = Q.defer();\n  }\n\n  self.odbc.createConnection(function (err, conn) {\n    if(!cb)\n    {\n      if (err) deferred.reject(err);\n    } else\n    {\n      if (err) return cb(err);\n    }\n\n    self.conn = conn;\n\n    if (self.connectTimeout || self.connectTimeout === 0)\n    {\n      self.conn.connectTimeout = self.connectTimeout;\n    }\n    if (typeof(self.systemNaming) !== 'undefined')\n    {\n      self.conn.systemNaming = self.systemNaming;\n    }\n\n    self.conn.open(connStr, function (err, result)\n    {\n      if(cb)\n      {\n        if (err) return cb(err);\n\n        self.connected = true;\n\n        return cb(err, result);\n      } \n      else\n      {\n        if(err) deferred.reject(err);\n\n        self.connected = true;\n        deferred.resolve(result);\n      }\n    }); //conn.open\n  }); // odbc.createConnection\n\n  return deferred ? deferred.promise : null;\n}; // Database.open function\n\nDatabase.prototype.openSync = function (connStr)\n{\n  var self =  this;\n\n  self.conn = self.odbc.createConnectionSync();\n\n  if (self.connectTimeout || self.connectTimeout === 0)\n  {\n    self.conn.connectTimeout = self.connectTimeout;\n  }\n  if (typeof(self.systemNaming) !== 'undefined')\n  {\n    self.conn.systemNaming = self.systemNaming;\n  }\n\n  if (typeof(connStr) === \"object\")\n  {\n    var obj = connStr;\n    connStr = \"\";\n\n    Object.keys(obj).forEach(function (key) {\n      connStr += key + \"=\" + obj[key] + \";\";\n    });\n  }\n\n  var result = self.conn.openSync(connStr);\n\n  if (result)\n  {\n    self.connected = true;\n  }\n\n  return result;\n}; // Database.openSync\n\nDatabase.prototype.close = function (cb)\n{\n  var self = this, deferred;\n  if(!cb) \n  {\n    deferred = Q.defer();\n  }\n\n  self.queue.push(function (next) {\n    if(self.conn)\n    {\n      self.conn.close(function (err) {\n        self.connected = false;\n        delete self.conn;\n\n        if (cb)\n        {\n          cb(err);\n        } else\n        {\n          deferred.resolve(err);\n        }\n        return next();\n      });\n    }\n    else\n    {\n      self.connected = false;\n    }\n  }); // self.queue.push\n\n  return deferred ? deferred.promise : false;\n}; // Database.close\n\nDatabase.prototype.closeSync = function ()\n{\n  var self = this;\n\n  var result;\n  if(self.conn) result = self.conn.closeSync();\n\n  self.connected = false;\n  delete self.conn;\n\n  return result\n}; // closeSync\n\nDatabase.prototype.query = function (query, params, cb)\n{\n  var self = this, deferred, sql, resultset = [], multipleResultSet = false;\n\n  exports.debug && console.log(getElapsedTime(), \"odbc.js:query() => Entry\");\n  //support for promises\n  if (!cb && typeof params !== 'function')\n  {\n    deferred = Q.defer();\n    !params ? params = null : '';\n  }\n\n  if (typeof(params) === 'function')\n  {\n    cb = params;\n    params = null;\n  }\n\n  if (!self.connected)\n  {\n    deferred ? deferred.reject({ message : \"Connection not open.\"}) : \n               cb({ message : \"Connection not open.\"}, [], false);\n    return deferred ?  deferred.promise : false;\n  }\n\n  self.queue.push(function (next) {\n    function cbQuery (initialErr, result, outparams)\n    {\n      if(outparams) {\n        resultset = outparams;\n        multipleResultSet = true;\n      }\n      if (result && typeof(result) === 'object') {\n        fetchMore();\n      } else {\n        cb(initialErr, resultset);\n        return next();\n      }\n\n      function fetchMore()\n      {\n        if (self.fetchMode)\n        {\n          result.fetchMode = self.fetchMode;\n        }\n\n        result.fetchAll(function (err, data, rowcount) {\n          var moreResults = false, moreResultsError = null;\n\n          // If there is any error, return it now only.\n          if( err || initialErr )\n          {\n            // For pooled connection, if we get SQL30081N, then close\n            // the connection now only and then proceed.\n            if(self.realClose){\n              if((err && err['message'] &&\n                      err['message'].search(\"SQL30081N\") != -1) ||\n                 (initialErr && initialErr['message'] &&\n                  initialErr['message'].search(\"SQL30081N\") != -1))\n              {\n                self.closeSync();\n              }\n            }\n            if(multipleResultSet) resultset.push(data);\n            else resultset = data;\n            deferred ? deferred.reject(initialErr || err) : cb(initialErr || err, resultset);\n            result.closeSync();\n            initialErr = null;\n            err = null;\n            return next();\n          }\n\n          // Get the result data\n          try\n          {\n            if(rowcount)  // Check for more result set.\n                moreResults = result.moreResultsSync();\n          }\n          catch (e)\n          {\n            moreResultsError = e;\n            moreResults = false;\n          }\n\n          //close the result before calling back\n          //if there are not more result sets\n          if (moreResults)\n          {\n              if( data.length ) resultset.push(data);\n              multipleResultSet = true;\n              fetchMore();\n          }\n          else\n          {\n            result.closeSync();\n            if( data.length ) {\n              if(multipleResultSet) resultset.push(data);\n              else resultset = data;\n            }\n\n            exports.debug && console.log(getElapsedTime(), \"odbc.js:query() => Done.\");\n            // send exception error and/or data to callback function.\n            // only once with all the results.\n            !cb ? deferred.resolve(resultset) : cb(moreResultsError, resultset);\n          }\n          \n          moreResultsError = null;\n          return next();\n        });\n      }\n    } //function cbQuery\n\n    if(typeof query === \"object\")\n    {\n        sql = query.sql;\n        if(query.params) params = query.params;\n    }\n    else\n    {\n        sql = query;\n    }\n    exports.debug && console.log(getElapsedTime(), \"odbc.js:query() => \", sql);\n    if (params)\n    {\n      if(Array.isArray(params))\n      {\n        var err = parseParams(params);\n        if(err) deferred ? deferred.reject(err) : cb(err);\n      }\n      if(typeof query === 'object')\n      {\n          query.params = params;\n          self.conn.query(query, cbQuery);\n      }\n      else\n          self.conn.query(query, params, cbQuery);\n    }\n    else\n    {\n      self.conn.query(query, cbQuery);\n    }\n  }); //self.queue.push\n  return deferred ? deferred.promise : false;\n}; // Database.query\n\nDatabase.prototype.queryResult = function (query, params, cb)\n{\n  var self = this, sql;\n\n  if (typeof(params) === 'function')\n  {\n    cb = params;\n    params = null;\n  }\n\n  if (!self.connected)\n  {\n    return cb({ message : \"Connection not open.\"}, null);\n  }\n\n  if(typeof query === \"object\")\n  {\n      sql = query.sql;\n      if(query.params) params = query.params;\n  }\n  else\n  {\n      sql = query;\n  }\n\n  exports.debug && console.log(getElapsedTime(), \"odbc.js:queryResult() => \", sql);\n  self.queue.push(function (next) {\n    //ODBCConnection.query() is the fastest-path querying mechanism.\n    if (params)\n    {\n      if(Array.isArray(params))\n      {\n        var err = parseParams(params);\n        if(err) cb(err);\n      }\n      if(typeof query === 'object')\n      {\n        query.params = params;\n        self.conn.query(query, cbQuery);\n      }\n      else\n        self.conn.query(sql, params, cbQuery);\n    }\n    else\n    {\n      self.conn.query(sql, cbQuery);\n    }\n\n    function cbQuery (err, result)\n    {\n      if (err)\n      {\n        cb(err, null);\n        return next();\n      }\n\n      if (self.fetchMode)\n      {\n        result.fetchMode = self.fetchMode;\n      }\n\n      cb(err, result);\n\n      return next();\n    } // function cbQuery\n  }); //self.queue.push\n}; // Database.queryResult\n\nDatabase.prototype.queryResultSync = function (query, params)\n{\n  var self = this, result, sql;\n\n  if (!self.connected)\n  {\n    throw ({ message : \"Connection not open.\"});\n  }\n\n  if(typeof query === \"object\")\n  {\n      sql = query.sql;\n      if(query.params) params = query.params;\n  }\n  else\n  {\n      sql = query;\n  }\n\n  exports.debug && console.log(getElapsedTime(), \"odbc.js:queryResultSync() => \", sql);\n  if (params)\n  {\n    if(Array.isArray(params))\n    {\n        var err = parseParams(params);\n        if(err) cb(err);\n    }\n    if(sql.search(/^call /i))\n    {\n      if(typeof query === 'object')\n      {\n        query.params = params;\n        self.conn.querySync(query);\n      }\n      else\n        result = self.conn.querySync(sql, params);\n    }\n    else // Its a CALL statement.\n    {\n      result = self.conn.querySync({\"sql\":sql, \"params\":params, \"noResults\":true});\n      return result;\n    }\n  }\n  else\n  {\n    result = self.conn.querySync(sql);\n  }\n\n  if (self.fetchMode)\n  {\n    result.fetchMode = self.fetchMode;\n  }\n\n  return result;\n}; // Database.queryResultSync\n\nDatabase.prototype.querySync = function (query, params)\n{\n  var self = this, result, sql, outparams = null;\n\n  if (!self.connected)\n  {\n    throw ({ message : \"Connection not open.\"});\n  }\n\n  if(typeof query === \"object\")\n  {\n      sql = query.sql;\n      if(query.params) params = query.params;\n  }\n  else\n  {\n      sql = query;\n  }\n\n  exports.debug && console.log(getElapsedTime(), \"odbc.js:querySync() => \", sql);\n  if (params)\n  {\n    if(Array.isArray(params))\n    {\n        var err = parseParams(params);\n        if(err) return err;\n    }\n    if(typeof query === 'object')\n    {\n        query.params = params;\n        result = self.conn.querySync(query);\n    }\n    else \n    {\n      result = self.conn.querySync(sql, params);\n    }\n  }\n  else\n  {\n    result = self.conn.querySync(query);\n  }\n\n  if(Array.isArray(result))\n  {\n    if(result[1]) { \n        outparams = result[1]; // INOUT and OUT param values for SP.\n    }\n    result = result[0];\n  }\n  if(!result) return outparams;  // For noResults.\n\n  // Processing for resultset.\n  var data, resultset = [], moreResults = true, moreResultsError = null;\n  var nullresult = true;\n\n  if(outparams) {\n      resultset = outparams;\n      nullresult = false;\n  }\n  if (self.fetchMode)\n  {\n    result.fetchMode = self.fetchMode;\n  }\n\n  while(moreResults)\n  {\n      data = result.fetchAllSync();\n      if(!data.length) {\n          moreResults = false;\n          break;\n      }\n      try\n      {\n          moreResults = result.moreResultsSync();\n      }\n      catch (e)\n      {\n          moreResultsError = e;\n          moreResults = false;\n          break;\n      }\n      if(data.length) {\n          if(nullresult && !moreResults) resultset = data;\n          else resultset.push(data);\n          nullresult = false;\n      }\n  }\n  result.closeSync();\n\n  if(moreResultsError) return moreResultsError;\n  if(nullresult) return [];\n\n  return resultset;\n}; // Database.querySync\n\nDatabase.prototype.queryStream = function queryStream(sql, params) \n{\n  var self = this;\n  var stream = new Readable({ objectMode: true });\n  var results;\n  stream._read = function() \n  {\n    // after the first internal call to _read, the 'results' should be set\n    // and the stream can continue fetching the results\n    if (results) return self.fetchStreamingResults(results, stream);\n\n    // in the first call to _read the stream starts to emit data once we've \n    // queried for results\n    return self.queryResult(sql, params, function (err, result) \n    {\n      if (err) \n      {\n        return process.nextTick(function () { stream.emit('error', err); });\n      }\n      results = result;\n      return self.fetchStreamingResults(results, stream);\n    });\n  };\n  return stream;\n};\n\nDatabase.prototype.fetchStreamingResults = function(results, stream) \n{\n  var self = this;\n  return results.fetch(function (err, data) \n  {\n    if (err) \n    {\n      return process.nextTick(function () { stream.emit('error', err); });\n    }\n    // when no more data returns, return push null to indicate the end of stream\n    if (!data) \n    { \n      return stream.push(null);\n    }\n    // if pushing the data returns 'true', that means we can query and push more \n    // immediately othewise the _read function will be called again (executing \n    // this function) once the reading party is ready to recieve more\n    if (stream.push(data))\n    {\n      return self.fetchStreamingResults(results, stream);\n    }\n  });\n};\n\nDatabase.prototype.beginTransaction = function (cb)\n{\n  var self = this\n      , deferred = null\n      , onBeginTransaction;\n  if(!cb) \n  {\n    deferred = Q.defer();\n    onBeginTransaction = function(err) \n    {\n      if(err) \n      {\n        deferred.reject(err);\n      }\n      else \n      {\n        deferred.resolve(true);\n      }\n    };\n  }\n\n  self.conn.beginTransaction(deferred ? onBeginTransaction : cb);\n  self.conn.inTransaction = true;\n\n  return deferred ? deferred.promise : self;\n};\n\nDatabase.prototype.endTransaction = function (rollback, cb)\n{\n  var self = this;\n\n  self.conn.endTransaction(rollback, cb);\n  self.conn.inTransaction = false;\n\n  return self;\n};\n\nDatabase.prototype.commitTransaction = function (cb)\n{\n  var self = this, deferred = null, onEndTransaction;\n  if(!cb) \n  {\n    deferred = Q.defer();\n    onEndTransaction = function(err) \n    {\n      if(err) \n      {\n        deferred.reject(err);\n      }\n      else \n      {\n        deferred.resolve(true);\n      }\n    };\n  }\n\n  //don't rollback\n  self.conn.endTransaction(false, deferred ? onEndTransaction : cb); \n  self.conn.inTransaction = false;\n\n  return deferred ? deferred.promise : self;\n};\n\nDatabase.prototype.rollbackTransaction = function (cb)\n{\n  var self = this, deferred = null, onEndTransaction;\n  if(!cb) {\n    deferred = Q.defer();\n    onEndTransaction = function(err) {\n      if(err) {\n        deferred.reject(err);\n      }\n      else {\n        deferred.resolve(true);\n      }\n    };\n  }\n\n  self.conn.endTransaction(true, deferred ? onEndTransaction : cb); //rollback\n  self.conn.inTransaction = false;\n\n  return deferred ? deferred.promise : self;\n};\n\nDatabase.prototype.beginTransactionSync = function ()\n{\n  var self = this;\n\n  self.conn.beginTransactionSync();\n  self.conn.inTransaction = true;\n\n  return self;\n};\n\nDatabase.prototype.endTransactionSync = function (rollback)\n{\n  var self = this;\n\n  self.conn.endTransactionSync(rollback);\n  self.conn.inTransaction = false;\n\n  return self;\n};\n\nDatabase.prototype.commitTransactionSync = function ()\n{\n  var self = this;\n\n  self.conn.endTransactionSync(false); //don't rollback\n  self.conn.inTransaction = false;\n\n  return self;\n};\n\nDatabase.prototype.rollbackTransactionSync = function ()\n{\n  var self = this;\n\n  self.conn.endTransactionSync(true); //rollback\n  self.conn.inTransaction = false;\n\n  return self;\n};\n\nDatabase.prototype.columns = function(catalog, schema, table, column, callback) \n{\n  var self = this;\n  if (!self.queue) self.queue = [];\n\n  callback = callback || arguments[arguments.length - 1];\n\n  self.queue.push(function (next) \n  {\n    self.conn.columns(catalog, schema, table, column, function (err, result) \n    {\n      if (err) return callback(err, [], false);\n\n      result.fetchAll(function (err, data) \n      {\n        result.closeSync();\n        callback(err, data);\n        return next();\n      });\n    });\n  });\n};\n\nDatabase.prototype.tables = function(catalog, schema, table, type, callback)\n{\n  var self = this;\n  if (!self.queue) self.queue = [];\n\n  callback = callback || arguments[arguments.length - 1];\n\n  self.queue.push(function (next) \n  {\n    self.conn.tables(catalog, schema, table, type, function (err, result) \n    {\n      if (err) return callback(err, [], false);\n\n      result.fetchAll(function (err, data) \n      {\n        result.closeSync();\n        callback(err, data);\n        return next();\n      });\n    });\n  });\n};\n\nDatabase.prototype.describe = function(obj, callback)\n{\n  var self = this;\n\n  if (typeof(callback) !== \"function\")\n  {\n    throw({\n      error : \"[node-odbc] Missing Arguments\",\n      message : \"You must specify a callback function in order \" +\n                \"for the describe method to work.\"\n    });\n\n    return false;\n  }\n\n  if (typeof(obj) !== \"object\")\n  {\n    callback({\n      error : \"[node-odbc] Missing Arguments\",\n      message : \"You must pass an object as argument 0 if you want \" +\n                \"anything productive to happen in the describe method.\"\n    }, []);\n\n    return false;\n  }\n\n  if (!obj.database)\n  {\n    callback({\n      error : \"[node-odbc] Missing Arguments\",\n      message : \"The object you passed did not contain a database \" +\n                \"property. This is required for the describe method to work.\"\n    }, []);\n\n    return false;\n  }\n\n  //set some defaults if they weren't passed\n  obj.schema = obj.schema || \"%\";\n  obj.type = obj.type || \"table\";\n\n  if (obj.table && obj.column)\n  {\n    //get the column details\n    self.columns(obj.database, obj.schema, obj.table, obj.column, callback);\n  }\n  else if (obj.table)\n  {\n    //get the columns in the table\n    self.columns(obj.database, obj.schema, obj.table, \"%\", callback);\n  }\n  else\n  {\n    //get the tables in the database\n    self.tables(obj.database, obj.schema, null, obj.type || \"table\", callback);\n  }\n}; //Database.describe\n\nDatabase.prototype.prepare = function (sql, cb)\n{\n  var self = this, deferred;\n\n  if(!cb) \n  {\n    deferred = Q.defer();\n  }\n\n  self.conn.createStatement(function (err, stmt) \n  {\n    if(err)\n    {\n      if(cb)\n      {\n        return cb(err);\n      } else\n      {\n        deferred.reject(err);\n      }\n    }\n\n    stmt.queue = new SimpleQueue();\n\n    stmt.prepare(sql, function (err) \n    {\n      if (err)\n      {\n        if(cb)\n        {\n          return cb(err);\n        } else\n        {\n          deferred.reject(err)\n        }\n      }\n\n      deferred ? deferred.resolve(stmt) : cb(null, stmt);\n    });\n  });\n  return deferred ? deferred.promise : null;\n};\n\nDatabase.prototype.prepareSync = function (sql)\n{\n  var self = this;\n\n  var stmt = self.conn.createStatementSync();\n\n  stmt.queue = new SimpleQueue();\n\n  stmt.prepareSync(sql);\n\n  return stmt;\n};\n\nDatabase.prototype.setIsolationLevel = function(isolationLevel) \n{\n  var self = this;\n  return (self.conn.setIsolationLevel(isolationLevel));\n};\n\n//Proxy all of the ODBCStatement functions so that they are queued\nodbc.ODBCStatement.prototype._execute = odbc.ODBCStatement.prototype.execute;\nodbc.ODBCStatement.prototype._executeSync = odbc.ODBCStatement.prototype.executeSync;\nodbc.ODBCStatement.prototype._executeDirect = odbc.ODBCStatement.prototype.executeDirect;\nodbc.ODBCStatement.prototype._executeDirectSync = odbc.ODBCStatement.prototype.executeDirectSync;\nodbc.ODBCStatement.prototype._executeNonQuery = odbc.ODBCStatement.prototype.executeNonQuery;\nodbc.ODBCStatement.prototype._executeNonQuerySync = odbc.ODBCStatement.prototype.executeNonQuerySync;\nodbc.ODBCStatement.prototype._prepare = odbc.ODBCStatement.prototype.prepare;\nodbc.ODBCStatement.prototype._bind = odbc.ODBCStatement.prototype.bind;\nodbc.ODBCStatement.prototype._bindSync = odbc.ODBCStatement.prototype.bindSync;\n\nodbc.ODBCStatement.prototype.execute = function (params, cb)\n{\n  var self = this, deferred;\n  // promises logic\n  if (!cb && typeof params !== 'function')\n  {\n    deferred = Q.defer();\n    // if(!params)\n    // {\n    //   params = null;\n    // }\n\n  }\n\n  self.queue = self.queue || new SimpleQueue();\n\n  if (!cb)\n  {\n    cb = params;\n    params = null;\n  }\n\n  self.queue.push(function (next) {\n    //If params were passed to this function, then bind them and\n    //then execute.\n    if (params)\n    {\n      if(Array.isArray(params))\n      {\n        var err = parseParams(params);\n        if(err)\n        {\n          if(!deferred)\n          {\n            cb(err);\n          } else\n          {\n            deferred.reject(err);\n          }\n        }\n      }\n      self._bind(params, function (err) {\n        if (err) {\n          if(!deferred)\n          {\n            cb(err);\n          } else\n          {\n            deferred.reject(err);\n          }\n          return next();\n        }\n\n        self._execute(function (err, result, outparams) {\n          if(!deferred)\n          {\n            cb(err, result, outparams);\n          } else\n          {\n            if(err)\n            {\n              deferred.reject(err);\n            } else\n            {\n              deferred.resolve(result, outparams);\n            }\n          }\n\n          return next();\n        });\n      });\n    }\n    //Otherwise execute and pop the next bind call\n    else\n    {\n      self._execute(function (err, result, outparams) {\n        if(!deferred)\n        {\n          cb(err, result, outparams);\n        } else\n        {\n          if(err)\n          {\n            deferred.reject(err);\n          } else\n          {\n            deferred.resolve(result, outparams);\n          }\n        }\n\n        //NOTE: We only execute the next queued bind call after\n        // we have called execute() or executeNonQuery(). This ensures\n        // that we don't call a bind() a bunch of times without ever\n        // actually executing that bind. Not\n        self.bindQueue && self.bindQueue.next();\n\n        return next();\n      });\n    }\n  });\n  return deferred ? deferred.promise : null;\n};\n\nodbc.ODBCStatement.prototype.executeSync = function (params)\n{\n  var self = this, err;\n\n  //If params are passed to this function, first bind them and\n  //then execute.\n  if (params)\n  {\n      err = self.bindSync(params);\n      if(err !== true) console.log(err);\n  }\n  return self._executeSync();\n};\n\nfunction parseParams(params)\n{\n    var err, prm, paramtype, ctype, sqltype, datatype, data, len;\n    for (var i = 0; i < params.length; i++)\n    {\n        if(Object.prototype.toString.call(params[i]) == \"[object Object]\")\n        {\n            //{ParamType:\"INPUT\", DataType:\"BLOB\", Data:imgfile}\n            //{\"ParamType\":\"INPUT\", CType:\"BINARY\", SQLType:\"BLOB\",Data:imgfile}\n            paramtype = 1; ctype = undefined; sqltype = undefined;\n            datatype = undefined; data = undefined, len = 0;\n            prm = params[i];\n            if(prm.ParamType)\n            {\n                if(Number.isInteger(prm.ParamType))\n                {\n                    if(prm.ParamType > 0 && prm.ParamType < 5)\n                        paramtype = prm.ParamType;\n                }\n                else if(prm.ParamType == \"OUTPUT\")\n                    paramtype = 4; // SQL_PARAM_OUTPUT\n                else if(prm.ParamType == \"INOUT\")\n                    paramtype = 2; // SQL_PARAM_INPUT_OUTPUT\n                else if(prm.ParamType == \"FILE\")\n                    paramtype = 3; // SQLBindFileToParam()\n            }\n\n            if(prm.CType)\n            {\n                if(Number.isInteger(prm.CType))\n                {\n                    ctype = prm.CType;\n                }\n                else if(prm.CType == \"CHAR\")\n                    ctype = 1;\n                else if(prm.CType == \"BINARY\")\n                    ctype = -2;\n                else if(prm.CType == \"INTEGER\")\n                    ctype = 4;\n            }\n\n            // Either SQLType or DataType must be entered.\n            // If SQLType is used, DataType will be ignored.\n            if(prm.SQLType || prm.DataType)\n            {\n                var type = prm.SQLType || prm.DataType;\n                if(Number.isInteger(type))\n                {\n                    sqltype = type;\n                }\n                else if(type == \"CHAR\")\n                {\n                    sqltype = 1;                 // SQL_CHAR\n                    if(!ctype) ctype = sqltype;\n                }\n                else if(type == \"BINARY\")\n                {\n                    sqltype = -2;\n                    if(!ctype) ctype = sqltype;\n                }\n                else if(type == \"BLOB\")\n                {\n                    sqltype = -98;               // SQL_BLOB\n                    if(!ctype) ctype = -2;\n                }\n                else if(type == \"CLOB\")\n                {\n                    sqltype = -99;\n                    if(!ctype) ctype = 1;\n                }\n                else if(type == \"DBCLOB\")\n                {\n                    sqltype = -350;\n                    if(!ctype) ctype = sqltype;\n                }\n                else if(type == \"XML\")\n                {\n                    sqltype = -370;\n                    if(!ctype) ctype = 1;\n                }\n                else if(type == \"GRAPHIC\")\n                {\n                    sqltype = -95;\n                    if(!ctype) ctype = -99; //SQL_C_DBCHAR\n                }\n                else if(type == \"VARGRAPHIC\")\n                {\n                    sqltype = -96;\n                    if(!ctype) ctype = -99; //SQL_C_DBCHAR\n                }\n                else if(type == \"LONGGRAPHIC\")\n                {\n                    sqltype = -97;\n                    if(!ctype) ctype = -99; //SQL_C_DBCHAR\n                }\n            }\n            if(prm.Length > 0 && Number.isInteger(prm.Length))\n            {\n                len = prm.Length;\n            }\n\n            if(prm.Data === undefined )\n            {\n                err = \"odbc.js:parseParams =>Data is missing from \" + JSON.stringify(prm);\n                break;\n            }\n            if(Number.isInteger(prm.Data))\n            {\n                if(!ctype) ctype = -25; // SQL_C_SBIGINT\n                if(!sqltype) sqltype = -5; // SQL_BIGINT\n\n            }\n            else if( (paramtype == 4) && (prm.Data === \"\") )\n            {\n                prm.Data = \"abc\";\n            }\n\n            if(!ctype) ctype = 1;\n            if(!sqltype) sqltype = 1;\n            if(paramtype == 3) // For BindFileToParam()\n            {\n                ctype = 1;\n                if(!((sqltype == -98) || (sqltype == -99) ||\n                     (sqltype == -350) || (sqltype == -370)))\n                {\n                    err = \"odbc.js:parseParams => DataType is missing form \" + prm;\n                    break;\n                }\n            }\n\n            params[i] = [paramtype, ctype, sqltype, prm.Data, len];\n        }\n        //console.log(i + \"th param = \" + params[i]);\n    }\n    return err;\n}\n\nif(Number.isInteger === undefined)   // node.js < v0.12.0 do not support isInteger\n{\n    Number.isInteger = function(x)\n    {\n        if((typeof x === 'number') && (x % 1 === 0)) return true;\n        else return false;\n    };\n}\n\nodbc.ODBCStatement.prototype.executeDirect = function (sql, cb) \n{\n  var self = this;\n\n  self.queue = self.queue || new SimpleQueue();\n\n  self.queue.push(function (next) {\n    self._executeDirect(sql, function (err, result) {\n      cb(err, result);\n\n      return next();\n    });\n  });\n};\n\nodbc.ODBCStatement.prototype.executeNonQuery = function (params, cb) \n{\n  var self = this, deferred;\n\n  if (!cb && typeof params !== 'function')\n  {\n      deferred = Q.defer();\n  }\n  self.queue = self.queue || new SimpleQueue();\n\n  if (!cb) \n  {\n    cb = params;\n    params = null;\n  }\n\n  self.queue.push(function (next) {\n    //If params were passed to this function, then bind them and\n    //then executeNonQuery.\n    if (params) \n    {\n      if(Array.isArray(params))\n      {\n        var err = parseParams(params);\n        if(err) \n        {\n          if(!deferred)\n          {\n            if(cb) cb(err);\n          }\n          else\n          {\n            deferred.reject(err);\n          }\n        }\n      }\n      self._bind(params, function (err) {\n        if (err) {\n          if(!deferred) \n          {\n            if(cb) cb(err)\n          } \n          else\n          {\n            deferred.reject(err);\n          }\n          return next();\n        }\n\n        self._executeNonQuery(function (err, result) {\n          if(!deferred) \n          {\n            if(cb) cb(err, result);\n          } \n          else\n          {\n            if(err)\n            {\n              deferred.reject(err);\n            } \n            else\n            {\n              deferred.resolve(result);\n            }\n          }\n          return next();\n        });\n      });\n    }\n    //Otherwise executeNonQuery and pop the next bind call\n    else {\n      self._executeNonQuery(function (err, result) {\n        if(!deferred) \n        {\n          if(cb) cb(err, result);\n        } \n        else\n        {\n          if(err)\n          {\n            deferred.reject(err);\n          } \n          else\n          {\n            deferred.resolve(result);\n          }\n        }\n\n        //NOTE: We only execute the next queued bind call after\n        // we have called execute() or executeNonQuery(). This ensures\n        // that we don't call a bind() a bunch of times without ever\n        // actually executing that bind. Not\n        self.bindQueue && self.bindQueue.next();\n\n        return next();\n      });\n    }\n  });\n  return deferred ? deferred.promise : null;\n};\n\nodbc.ODBCStatement.prototype.prepare = function (sql, cb) {\n  var self = this;\n\n  self.queue = self.queue || new SimpleQueue();\n\n  self.queue.push(function (next) {\n    self._prepare(sql, function (err) {\n      if(cb) cb(err);\n\n      return next();\n    });\n  });\n};\n\n// Function to bind parameters before execute or executeSync\nodbc.ODBCStatement.prototype.bind = function (ary, cb) {\n  var self = this;\n\n  self.bindQueue = self.bindQueue || new SimpleQueue();\n\n  self.bindQueue.push(function () {\n    if(Array.isArray(ary))\n    {\n      var err = parseParams(ary);\n      if(err && cb) cb(err);\n    }\n    self._bind(ary, function (err) {\n      if(cb) cb(err);\n\n      //NOTE: we do not call next() here because\n      //we want to pop the next bind call only\n      //after the next execute call\n    });\n  });\n};\n\n// Async Function to bind parameters before execute or executeSync\nodbc.ODBCStatement.prototype.bindSync = function (ary) {\n    var self = this;\n    if(Array.isArray(ary))\n    {\n      var err = parseParams(ary);\n      if(err) return false;\n    }\n    return self._bindSync(ary); \n};\n\n\nmodule.exports.Pool = Pool;\n\nPool.count = 0;\n\nfunction Pool (_options) {\n  var self = this;\n  self.options = {};\n  self.maxPoolSize = 0;\n  if(_options) \n  {\n    if(_options.idleTimeout && !isNaN(_options.idleTimeout))\n      self.options.idleTimeout = _options.idleTimeout;\n    if(_options.autoCleanIdle)\n      self.options.autoCleanIdle = _options.autoCleanIdle;\n    if(_options.maxPoolSize)\n      self.maxPoolSize = _options.maxPoolSize;\n    if(_options.connectTimeout)\n      self.options.connectTimeout = _options.connectTimeout;\n    if(_options.systemNaming)\n      self.options.systemNaming=_options.systemNaming;\n  }\n  self.index = Pool.count++;\n  self.availablePool = {};\n  self.usedPool = {};\n  self.poolSize = 0;\n  if(!ENV) ENV = new odbc.ODBC();\n  self.odbc = ENV;\n  self.options.connectTimeout = self.options.connectTimeout || 60;\n}\n\nPool.prototype.open = function (connStr, callback)\n{\n  var self = this\n    , db\n    ;\n\n  //check to see if we already have a connection for this connection string\n  if (self.availablePool[connStr] && self.availablePool[connStr].length)\n  {\n    db = self.availablePool[connStr].shift();\n    db.lastUsed=null;\n    self.usedPool[connStr] = self.usedPool[connStr] || [];\n    self.usedPool[connStr].push(db);\n    callback(null, db);\n  }\n  else if((self.maxPoolSize > 0) && (self.poolSize >= self.maxPoolSize))\n  {\n    var timeout = self.options.connectTimeout;\n    var error = {\"message\":\"Connection Timeout Occurred, Pool is full.\"};\n    var interval =  setInterval(function () {\n      if (self.availablePool[connStr] && self.availablePool[connStr].length)\n      {\n        db = self.availablePool[connStr].shift();\n        db.lastUsed=null;\n        self.usedPool[connStr] = self.usedPool[connStr] || [];\n        self.usedPool[connStr].push(db);\n        clearInterval(interval);\n        callback(null, db);\n      }\n      if(timeout === 0) \n      {\n        clearInterval(interval);\n        callback(error, null);\n      }\n      else \n      {\n        timeout--;\n      }\n    }, 1000);  //setInterval\n  }\n  else\n  {\n    if(typeof(self.options.odbc) === undefined)\n        self.options.odbc = self.odbc;\n    db = new Database(self.options);\n    self.poolSize++;\n\n    db.realClose = db.close;\n    db.close = function (cb)\n    {\n      var db = this;\n      db.lastUsed = Date.now();\n      //call back early, we can do the rest of this stuff after the client\n      //thinks that the connection is closed.\n      if(cb) cb(null);\n\n      // If this connection has some active transaction, rollback the\n      // transaction to free up the held resorces before moving back to\n      // the pool. So that, next request can get afresh connection from pool.\n      if(db.conn && db.conn.inTransaction)\n      {\n          db.rollbackTransaction(function(err){});\n      }\n\n      //remove this db from the usedPool\n      self.usedPool[connStr].splice(self.usedPool[connStr].indexOf(db), 1);\n\n      //move this connection back to the connection pool at the end.\n      if(db.conn)\n      {\n        self.availablePool[connStr] = self.availablePool[connStr] || [];\n        self.availablePool[connStr].push(db);\n\n        //start cleanUp if enabled\n        if(self.options.autoCleanIdle) self.cleanUp(connStr);\n      }\n      if(exports.debug) { \n        process.stdout.write(getElapsedTime());\n        console.dir(self);\n      }\n    };  // db.close function\n\n    db.open(connStr, function (error) {\n      exports.debug && console.log(\"%s odbc.js : pool[%s] : pool.db.open new connection.\", getElapsedTime(), self.index);\n      if(error)\n      {\n        self.poolSize--;\n      }\n      else\n      {\n        self.usedPool[connStr] = self.usedPool[connStr] || [];\n        db.created = Date.now();\n        self.usedPool[connStr].push(db);\n      }\n      callback(error, db);\n    }); //db.open\n  }\n};\n\nPool.prototype.init = function(count, connStr)\n{\n  var self = this;\n  var ret = false;\n\n  //check to see if we already have a connection for this connection string\n  if (self.availablePool[connStr] && self.availablePool[connStr].length)\n  {\n    console.log(\"Pool is already initialized and it has \"+\n           self.availablePool[connStr].length + \" available connections.\\n\");\n    return;\n  }\n  else\n  {\n    if((self.maxPoolSize > 0) && (count > self.maxPoolSize))\n    {\n        console.log(getElapsedTime(), \" ** Can not open connection more than max pool size.\\n\");\n        count = self.maxPoolSize;\n    }\n\n    if(typeof(self.options.odbc) === undefined)\n        self.options.odbc = self.odbc;\n    for(var i = 0; i < count; i++)\n    {\n        var db = new Database(self.options);\n        self.poolSize++;\n        try{\n            ret = db.openSync(connStr);\n        } catch (ret) {\n            self.poolSize--;\n            exports.debug && console.log(\"%s odbc.js: %d connection(s) initialized.\\n\", getElapsedTime(), self.poolSize);\n            return ret;\n        }\n        if(ret !== true) break; \n        exports.debug && console.log(\"%s odbc.js : pool[%s] : pool.init %d\", getElapsedTime(), self.index, i);\n\n        self.availablePool[connStr] = self.availablePool[connStr] || [];\n        db.created = Date.now();\n\n        db.realClose = db.close;\n        db.close = function (cb)\n        {\n          var db = this;\n          db.lastUsed = Date.now();\n          if(cb) cb(null);\n          if(db.conn && db.conn.inTransaction)\n          {\n              db.rollbackTransaction(function(err){});\n          }\n          self.usedPool[connStr].splice(self.usedPool[connStr].indexOf(db), 1);\n          if(db.conn)\n          {\n            self.availablePool[connStr] = self.availablePool[connStr] || [];\n            self.availablePool[connStr].push(db);\n            if(self.options.autoCleanIdle) self.cleanUp(connStr);\n          }\n        };  // db.close function\n        self.availablePool[connStr].push(db);\n    }\n    self.usedPool[connStr] = self.usedPool[connStr] || [];\n    exports.debug && console.log(getElapsedTime(), \"Max pool size = \" + self.maxPoolSize);\n    return ret;\n  }\n};// Pool.init()\n\nPool.prototype.setMaxPoolSize = function(size)\n{\n    var self = this;\n    self.maxPoolSize = size;\n    return true;\n};\n\nPool.prototype.setConnectTimeout = function(timeout)\n{\n    var self = this;\n    self.options.connectTimeout = timeout;\n    return true;\n};\n\n// Close idle connections\nPool.prototype.cleanUp = function(connStr, callback) {\n  var self = this;\n  if(self.availablePool[connStr].length < 2) return;\n\n  self.availablePool[connStr] = self.availablePool[connStr].filter(function(conn) \n  {\n    if(conn.lastUsed && \n       (Date.now()-conn.lastUsed > (self.options.idleTimeout || 1800 * 1000)) && \n       conn.realClose ) \n    {\n       conn.realClose(function() \n       {\n         if(self.poolSize) self.poolSize--;\n         exports.debug && console.log(\"odbc.js : pool[%s] : Pool.cleanUp() : \" +\n                 \"pool.realClose() : Connection duration : %s\", self.index, \n                 (Date.now() - conn.created)/1000);\n       });\n       return false;\n    }\n    else \n    {\n      return true;\n    }\n  });\n}; //Pool.cleanUp()\n\nPool.prototype.close = function (callback)\n{\n  var self = this\n    , required = 0\n    , received = 0\n    , connections\n    , key\n    , x\n    ;\n\n  exports.debug && console.log(\"%s odbc.js : pool[%s] : pool.close()\", getElapsedTime(), self.index);\n  //we set a timeout because a previous db.close() may\n  //have caused the a behind the scenes db.open() to prepare\n  //a new connection\n  setTimeout(function () {\n    //merge the available pool and the usedPool\n    var pools = {};\n\n    for (key in self.availablePool)\n    {\n      pools[key] = (pools[key] || []).concat(self.availablePool[key]);\n    }\n\n    for (key in self.usedPool)\n    {\n      pools[key] = (pools[key] || []).concat(self.usedPool[key]);\n    }\n\n    exports.debug && console.log(\"%s odbc.js : pool[%s] : pool.close() - setTimeout() callback\", getElapsedTime(), self.index);\n    //console.dir(pools);\n\n    if (Object.keys(pools).length === 0)\n    {\n      if (callback) return callback();\n      else return null;\n    }\n\n    for (key in pools)\n    {\n      connections = pools[key];\n      required += connections.length;\n\n      if(exports.debug) { \n        console.log(\"%s odbc.js : pool[%s] : pool.close() - processing pools %s - connections: %s\", \n                    getElapsedTime(), self.index, key, connections.length);\n      }\n\n      for (x = 0 ; x < connections.length; x ++)\n      {\n        (function (x) {\n          //call the realClose method to avoid\n          //automatically re-opening the connection\n          if(exports.debug) { \n            console.log(\"%s odbc.js : pool[%s] : pool.close() - calling realClose() for connection #%s\", \n                        getElapsedTime(), self.index, x);\n          }\n\n          if(connections[x].realClose) {\n           connections[x].realClose(function () {\n            if(exports.debug) { \n              console.log(\"%s odbc.js : pool[%s] : pool.close() - realClose() callback for connection #%s\", \n                          getElapsedTime(), self.index, x);\n            }\n            module.exports.close(connections[x]);\n            received += 1;\n            if(self.poolSize) self.poolSize--;\n\n            if (received === required)\n            {\n              if(callback) callback();\n\n              //prevent mem leaks\n              self = null;\n              connections = null;\n              required = null;\n              received = null;\n              key = null;\n\n              return;\n            }\n           }); // connections[x].realClose i.e. conn.close().\n          }\n          else {\n              exports.debug && console.log(\"%s realClose is not a member of connection %s\", getElapsedTime(), x);\n          }\n        })(x);\n      } //for loop.\n    } //for (key in pools)\n  }, 2000);  //setTimeout\n};  //Pool.close()\n","/home/travis/build/npmtest/node-npmtest-ibm_db/node_modules/ibm_db/lib/simple-queue.js":"module.exports = SimpleQueue;\n\nfunction SimpleQueue() {\n  var self = this;\n  \n  self.fifo = [];\n  self.executing = false;\n}\n\nSimpleQueue.prototype.push = function (fn) {\n  var self = this;\n  \n  self.fifo.push(fn);\n  \n  self.maybeNext();\n};\n\nSimpleQueue.prototype.maybeNext = function () {\n  var self = this;\n  \n  if (!self.executing) {\n    self.next();\n  }\n};\n\nSimpleQueue.prototype.next = function () {\n  var self = this;\n  \n  if (self.fifo.length) {\n    var fn = self.fifo.shift();\n    \n    self.executing = true;\n    \n    fn(function () {\n      self.executing = false;\n      \n      self.maybeNext();\n    });\n  }\n};","/home/travis/build/npmtest/node-npmtest-ibm_db/node_modules/ibm_db/installer/driverInstall.js":"/**\n * Node-ibm_db Installer file.\n */\n\nvar fs = require('fs');\nvar url = require('url');\nvar os = require('os');\nvar path = require('path');\nvar exec = require('child_process').exec;\nvar request = require('request');\n\nvar installerURL = 'https://public.dhe.ibm.com/ibmdl/export/pub/software/data/db2/drivers/odbc_cli';\nvar CURRENT_DIR = process.cwd();\nvar DOWNLOAD_DIR = path.resolve(CURRENT_DIR, 'installer');\nvar INSTALLER_FILE; \ninstallerURL = process.env.IBM_DB_INSTALLER_URL || installerURL;\ninstallerURL = installerURL + \"/\";\n\n//Function to download clidriver and install node-ibm_db\nvar install_node_ibm_db = function(file_url) {\n    var readStream;\n    var writeStream;\n    var platform = os.platform();\n    var arch = os.arch();\n    var endian = os.endianness();\n    var installerfileURL;\n\n    var fstream = require('fstream');\n    var unzipper = require('unzipper');\n\n    var IBM_DB_HOME, IBM_DB_INCLUDE, IBM_DB_LIB, IBM_DB_DIR;\n\n    if(platform == 'win32') {\n        if(arch == 'x64') {\n            var BUILD_FILE = path.resolve(CURRENT_DIR, 'build.zip');\n\n            //Windows node binary names should update here.\n            var ODBC_BINDINGS = 'build\\/Release\\/odbc_bindings.node';\n            var ODBC_BINDINGS_V12 = 'build\\/Release\\/odbc_bindings.node.0.12.7';\n            var ODBC_BINDINGS_V4 = 'build\\/Release\\/odbc_bindings.node.4.6.1';\n            var ODBC_BINDINGS_V6 = 'build\\/Release\\/odbc_bindings.node.6.9.1';\n\n            // Windows add-on binary for node.js v0.10.x has been discontinued.\n            if(Number(process.version.match(/^v(\\d+\\.\\d+)/)[1]) == 0.10){\n                console.log('\\nERROR: Found unsupported node.js version ' + process.version +\n                '\\nnode-ibm_db do not have precompiled add-on file odbc_bindings.node for\\n' +\n                'node.js v0.10.x on Widnows. Please use the latest version of node.js.\\n');\n                process.exit(1);\n            }\n\n            // Windows add-on binary for node.js v0.12.x has been deprecated.\n            if(Number(process.version.match(/^v(\\d+\\.\\d+)/)[1]) == 0.12){\n                console.log('\\nWARNING: Found node.js version ' + process.version +\n                '\\nSupport for node-ibm_db on Windows for node.js version 0.12.x is deprecated\\n' +\n                'and will be discontinued soon. Please use the latest version of node.js.\\n');\n            }\n\n            /*\n             * odbcBindingsNode will consist of the node binary-\n             * file name according to the node version in the system.\n             */\n            var odbcBindingsNode = (Number(process.version.match(/^v(\\d+\\.\\d+)/)[1]) < 4.0) && ODBC_BINDINGS_V12  ||\n            (Number(process.version.match(/^v(\\d+\\.\\d+)/)[1]) < 5.0) && ODBC_BINDINGS_V4 ||\n            (Number(process.version.match(/^v(\\d+\\.\\d+)/)[1]) < 7.0) && ODBC_BINDINGS_V6 || ODBC_BINDINGS ;\n\n            readStream = fs.createReadStream(BUILD_FILE);\n\n            /*\n             * unzipper will parse the build.zip file content and\n             * then it will check for the odbcBindingsNode\n             * (node Binary), when it gets that binary file,\n             * fstream.Writer will write the same node binary\n             * but the name will be odbc_bindings.node, and the other\n             * binary files and build.zip will be discarded.\n             */\n            readStream.pipe(unzipper.Parse())\n            .on('entry', function (entry) {\n                if(entry.path === odbcBindingsNode){\n                    entry.pipe(fstream.Writer(ODBC_BINDINGS));\n                } else {\n                    entry.autodrain();\n                }\n            })\n            .on('error', function(e) {\n                console.log('error',e);\n            })\n            .on('finish', function() {\n                fs.unlinkSync(BUILD_FILE);\n            });\n\n            removeUsedPackages();\n        } else {\n            console.log('Windows 32 bit not supported. Please use an ' +\n                        'x64 architecture.');\n            return;\n        }\n    }\n\n    /*\n     * IF: IBM_DB_HOME path is set,\n     * clidriver will not be download from remote location\n     * node-ibm_db will use local clidriver package stored in-\n     * IBM_DB_HOME path location.\n     * ELSE: platform specific compressed clidriver package will be download\n     * and then extract for further use.\n     */\n    if(process.env.IBM_DB_HOME) \n    {\n        IBM_DB_HOME = process.env.IBM_DB_HOME;\n        IBM_DB_INCLUDE = path.resolve(IBM_DB_HOME, 'include');\n        if (fs.existsSync(IBM_DB_HOME + \"/lib64\")) {\n           IBM_DB_LIB = path.resolve(IBM_DB_HOME, 'lib64');\n        } else if (fs.existsSync(IBM_DB_HOME + \"/lib32\")) {\n           IBM_DB_LIB = path.resolve(IBM_DB_HOME, 'lib32');\n        } else {\n           IBM_DB_LIB = path.resolve(IBM_DB_HOME, 'lib');\n        }\n        console.log('IBM_DB_HOME environment variable have already been set to '+IBM_DB_HOME);\n\n        if (!fs.existsSync(IBM_DB_HOME)) {\n            console.log(IBM_DB_HOME + ' directory does not exist. Please check if you have ' + \n                        'set the IBM_DB_HOME environment variable\\'s value correctly.');\n        }\n\n        if (!fs.existsSync(IBM_DB_INCLUDE)) {\n            console.log(IBM_DB_INCLUDE + ' directory does not exist. Please check if you have ' + \n                        'set the IBM_DB_HOME environment variable\\'s value correctly.');\n        }\n\n        if (!fs.existsSync(IBM_DB_LIB)) {\n            console.log(IBM_DB_LIB + ' directory does not exist. Please check if you have ' + \n                        'set the IBM_DB_HOME environment variable\\'s value correctly.');\n        }\n        if( platform != 'win32') {\n            if(!fs.existsSync(IBM_DB_HOME + \"/lib\"))\n                fs.symlinkSync(IBM_DB_LIB, path.resolve(IBM_DB_HOME, 'lib'));\n\n            if((platform == 'linux') || (platform =='aix') || \n               (platform == 'darwin' && arch == 'x64')) {\n                removeWinBuildArchive();\n                buildBinary(false);\n            } else {\n                console.log('Building binaries for node-ibm_db. This platform is not completely supported, you might encounter errors. In such cases please open an issue on our repository, https://github.com/ibmdb/node-ibm_db.');\n                buildBinary(false);\n            }\n        }\n    } else {\n        if(platform == 'win32') \n        {\n            if(arch == 'x64') {\n                installerfileURL = installerURL + 'ntx64_odbc_cli.zip';\n            }/* else {\n                installerfileURL = installerURL + 'nt32_odbc_cli.zip';\n            }*/\n        } \n        else if(platform == 'linux') \n        {\n            if(arch == 'x64') {\n                installerfileURL = installerURL + 'linuxx64_odbc_cli.tar.gz';\n            } else if(arch == 's390x') {\n                installerfileURL = installerURL + 's390x64_odbc_cli.tar.gz';\n            } else if(arch == 's390') {\n                installerfileURL = installerURL + 's390_odbc_cli.tar.gz';\n            } else if(arch == 'ppc64') {\n                if(endian == 'LE')\n                    installerfileURL = installerURL + 'ppc64le_odbc_cli.tar.gz';\n                else\n                    installerfileURL = installerURL + 'ppc64_odbc_cli.tar.gz';\n            } else if(arch == 'ppc32') {\n                installerfileURL = installerURL + 'ppc32_odbc_cli.tar.gz';\n            } else {\n                installerfileURL = installerURL + 'linuxia32_odbc_cli.tar.gz';\n            }\n        } \n        else if(platform == 'darwin') \n        {\n            if(arch == 'x64') {\n                installerfileURL = installerURL + 'macos64_odbc_cli.tar.gz';\n            } else {\n                console.log('Mac OS 32 bit not supported. Please use an ' +\n                            'x64 architecture.');\n                return;\n            }\n        } \n        else if(platform == 'aix')\n        {\n            if(arch == 'ppc')\n            {\n                installerfileURL = installerURL + 'aix32_odbc_cli.tar.gz';\n            }\n            else\n            {\n                installerfileURL = installerURL + 'aix64_odbc_cli.tar.gz';\n            }\n        }\n        else \n        {\n            installerfileURL = installerURL + platform + arch + \n                               '_odbc_cli.tar.gz';\n        }\n\n        if(!installerfileURL) {\n            console.log('Unable to fetch driver download file. Exiting the ' +\n                        'install process.');\n            process.exit(1);\n        }\n\n        var license_agreement = '\\n\\n****************************************\\nYou are downloading a package which includes the Node.js module for IBM DB2/Informix.  The module is licensed under the Apache License 2.0. The package also includes IBM ODBC and CLI Driver from IBM, which is automatically downloaded as the node module is installed on your system/device. The license agreement to the IBM ODBC and CLI Driver is available in '+DOWNLOAD_DIR+'   Check for additional dependencies, which may come with their own license agreement(s). Your use of the components of the package and dependencies constitutes your acceptance of their respective license agreements. If you do not accept the terms of any license agreement(s), then delete the relevant component(s) from your device.\\n****************************************\\n';\n\n        var file_name = url.parse(installerfileURL).pathname.split('/').pop();\n        INSTALLER_FILE = path.resolve(DOWNLOAD_DIR, file_name);\n\n        console.log('Downloading DB2 ODBC CLI Driver from ' +\n                    installerfileURL+'...\\n');\n\n        fs.stat(installerfileURL, function (err, stats) {\n            if (!err && stats.isFile()) {\n                INSTALLER_FILE = installerfileURL;\n                return copyAndExtractDriver();\n            }\n            return getInstallerFile(installerfileURL);\n        });\n\n    }  // * END OF EXECUTION */\n\n    function copyAndExtractDriver() {\n        if(platform == 'win32') {\n            readStream = fs.createReadStream(INSTALLER_FILE);\n\n            /* unzipper.Extract will extract the clidriver zipped-\n             * file content to DOWNLOAD_DIR.\n             */\n            var extractCLIDriver = readStream.pipe(unzipper.Extract({path: DOWNLOAD_DIR}));\n\n            /* After successful closing of the event,\n             * license_agreement and Download and extraction\n             * of DB2 ODBC CLI Driver acknowledgement will display.\n             */\n            extractCLIDriver.on('close', function() {\n                console.log(license_agreement);\n                console.log('Downloading and extraction of DB2 ODBC ' +\n                    'CLI Driver completed successfully... \\n');\n            });\n\n            extractCLIDriver.on('err', function() {\n                console.log(err);\n            });\n        } \n        else \n        {\n            var targz = require('targz');\n            var compress = targz.decompress({src: INSTALLER_FILE, dest: DOWNLOAD_DIR}, function(err){\n              if(err) {\n                console.log(err);\n                process.exit(1);\n              }\n              else {\n                console.log(license_agreement);\n                console.log('Downloading and extraction of DB2 ODBC ' +\n                            'CLI Driver completed successfully ...');\n                IBM_DB_HOME = path.resolve(DOWNLOAD_DIR, 'clidriver');\n                process.env.IBM_DB_HOME = IBM_DB_HOME.replace(/\\s/g,'\\\\ ');\n                buildBinary(true);\n                removeWinBuildArchive();\n              }\n            });\n        }\n    }\n\n    function buildBinary(isDownloaded) \n    {\n        var buildString = \"node-gyp configure build --IBM_DB_HOME=\\\"$IBM_DB_HOME\\\"\";\n        if(isDownloaded) {\n            buildString = buildString + \" --IS_DOWNLOADED=true\";\n        } else {\n            buildString = buildString + \" --IS_DOWNLOADED=false\";\n        }\n        if( platform == 'win32') \n        {\n            buildString = buildString + \" --IBM_DB_HOME_WIN=%IBM_DB_HOME%\";\n        }\n        var childProcess = exec(buildString, function (error, stdout, stderr) {\n            console.log(stdout);\n            if (error !== null) {\n                console.log(error);\n                process.exit(1);\n            }\n\n            if(platform == 'darwin' && arch == 'x64') \n            {\n                // Run the install_name_tool\n                var nameToolCommand = \"install_name_tool -change libdb2.dylib $IBM_DB_HOME/lib/libdb2.dylib ./build/Release/odbc_bindings.node\" ;\n                var nameToolCmdProcess = exec(nameToolCommand , \n                  function (error1, stdout1, stderr1) {\n                    if (error1 !== null) {\n                        console.log('Error setting up the lib path to ' +\n                            'odbc_bindings.node file.Error trace:\\n'+error1);\n                        process.exit(1);\n                    }\n                });\n            }\n            removeUsedPackages();\n        });\n    } //buildBinary\n\n    function removeUsedPackages()\n    {\n        var packages = [\"nan\", \"fstream\", \"unzipper\", \"targz\"];\n        for( var index = 0; index < packages.length; index++ )\n        {\n          var command = \"npm uninstall \" + packages[index];\n          var childProcess = exec(command, function (error, stdout, stderr) {\n            console.log(stdout);\n            if (error !== null) {\n                console.log(error);\n                // Ignore error and continue to remove other packages.\n                // Installation of ibm_db should not fail due to such errors.\n            }\n          });\n        }\n    }\n\n    function removeWinBuildArchive() \n    {\n        var WIN_BUILD_FILE = path.resolve(CURRENT_DIR, 'build.zip');\n        fs.exists(WIN_BUILD_FILE, function(exists) \n        {\n            if (exists) \n            {\n                fs.unlinkSync(WIN_BUILD_FILE);\n            }\n        });\n    }\n\n    // Function to download clidriver file using request module.\n    function getInstallerFile(installerfileURL) {\n        // Variable to save downloading progress\n        var received_bytes = 0;\n        var total_bytes = 0;\n\n        var outStream = fs.createWriteStream(INSTALLER_FILE);\n\n        request\n            .get(installerfileURL)\n                .on('error', function(err) {\n                    console.log(err);\n                })\n                .on('response', function(data) {\n                    total_bytes = parseInt(data.headers['content-length']);\n                })\n                .on('data', function(chunk) {\n                    received_bytes += chunk.length;\n                    showDownloadingProgress(received_bytes, total_bytes);\n                })\n                .pipe(outStream);\n\n        outStream.once('close', copyAndExtractDriver)\n        .once('error', function (err) {\n            cosole.log(err);\n        });\n    };\n\n    function showDownloadingProgress(received, total) {\n        var percentage = ((received * 100) / total).toFixed(2);\n        process.stdout.write((platform == 'win32') ? \"\\033[0G\": \"\\r\");\n        process.stdout.write(percentage + \"% | \" + received + \" bytes downloaded out of \" + total + \" bytes.\");\n    }\n\n}; //install_node_ibm_db\n\ninstall_node_ibm_db();\n"}